//_ ОБЕСПЕЧЕНИЕ БЕЗОПАСНОСТИ ДАННЫХ
// переменные меньше или равные размеру слова в ОС
// изменяются атомарно
// остальные подверженны риску

// лучший способ гарантировать безопасность данных
// это писать приложение так, чтобы одна задача имела доступ к одним ресурсам
// если это возможно

// когда не возможно используются методы обеспечения безопасности данных

//_ МЕТОДЫ ОБЕСПЕЧЕНИЯ БЕЗОПАСНОСТИ ДАННЫХ
//~ критическая секция
// когда внутри задачи я окружаю код такими функциями
taskENTER_CRITICAL();
// работа с данными
taskEXIT_CRITICAL();
// внутри них я запрещаю прерывания
// и данные изменятся или запишутся бкезопасно

// но есть минус, я могу пропустить событие
// это самый грубый метод

//~ приостановка шедулера
//  можно просто остановить планировщик
vTaskSuspendAll()
// прерывания при этом будут доступны
// но не какие функции API freeRTOS вызывать нельзя
// а потом заново запустить
xTaskResumeAll()

//_ МЬЮТЕКСЫ
// это типа специальный двоичный симафор
// задача удерживает данные до тех пор пока их не отпустит
//~ создание
// создается до старта задачи
xMutex = xSemaphoreCreateMutex()
// возвращает мьютекс или NULL

//~ захват значения 
// ставим значение ждать пока мьютекс не освободится
// если мьютекс занят, на этом этапе задача уйдет в сон
xSemaphoreTake( xMutex, portMAX_DELAY );
{
   // здесь код с доступом к общим ресурсам, заработает только по полученному мьютексу
}
xSemaphoreGive( xMutex );// отпускаем данные

//! ВНИМАТЕЛЬНО
// если задача с низким приоритетом возьмет мьютекс
// запустится задача с более высоким приоритетом
// и будет ждать этот мьютекс вечно
// потому что задача с низким приоритетом никогда не запустится
// избежать этого можно подняв приоритем мьютексодержателя до макс уровня
//! СТАРАЙСЯ СТАВИТЬ ОДИНАКОВЫЕ ПРИОРИТЕТЫ НА ЗАДАЧИ С ДОСТУПАМ К ОБЩИМ ДАННЫМ

//_ ВЗАИМНАЯ БЛОКИРОВКА
// задача А получает мьютекс Х
// задача Б вытесняет задачу А получает мьютекс задачи У 
// но не может получить мьютекс Х и уходит в блокировку
// задача А просывается и пытается получить мьютекс У
// но его держит задача В, А уходит в блокировку
// ОБЕ ЗАДАЧИ В БЛОКИРОВКЕ = DEADLOCK
// решается проектированием

//_ ГЕЙТКИПЕР
// доступ к данным выполняет только одна задача
// которая имеет очередь и наивысший приоритет
// все омтальные задачи просто посылают ему в очередь данные
// тогда никаких блокировок
// и прочих проблем