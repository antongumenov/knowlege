//>> ОЧЕРЕДИ 
// это отдельная сущьность
// которая не принадлежит задаче
// и в нее могут писать много задач
// и читать из нее могут много задач

// однако читают несколько задач крайне редко

// писать можно как в конец, так и в начало очереди

//<< практика
// на практике при прерывании я просто пишу в очередь
// задача обработчик спит пока не поступит сообщение  в очередь
// она будит задачу обработчик
// та читает с очереди и выполняет задачу

//<< распределение данных по читателям
// если несколько читающих
// то данные улетят к задаче с наивысшим прироритетом

// если у задач равные приоритеты
// то данные улетят к задаче которая ждада больше всего

//<< создание очереди
xQueueCreate(количество, размер элемента в байтах)
// если вернула не NULL - занчит все успешно
// а так возвращает xQueueHandle

//<< вставка в очередь
xQueueSend(очередь, *значение ,тики_ожидания_свободного_места) - вставка в конец
xQueueSendToBack(очередь, *значение ,тики_ожидания_свободного_места) - аналог xQueueSend() 
xQueueSendToFront(очередь, *значение ,тики_ожидания_свободного_места) - вставка в конец, в начало
// тики_ожидания_свободного_места - сколько ждать до освобождения очереди, если нет места
// вернет
pdPASS - если успех
errQUEUE_FULL - если ошибка

//<< чтение из очереди
xQueueReceive(очередь, *переменная_куда_писать, тики_ожидания_сообщения) - чтение с удалением из очереди
xQueuePeek(очередь, *переменная_куда_писать, тики_ожидания_сообщения) - чтение без удаления из очереди
// тики_ожидания_сообщения - сколько ждать появления сообщения
// вернет
pdPASS - если успех
errQUEUE_FULL - если ошибка

//<< чтение количества элементов
uxQueueMessagesWaiting(очередь) - сколько элементов в очереди
// если 0 то очередь пуста

//>> ПЕРЕДАЧА СТРУКТУР В ОЧЕРЕДЯХ
// часто несколько задач пишут, а только одна принимает
// чтобы понимть откуда данные можно пеерадвать данные в структуре с пометкой откуда они

//>> ПЕРЕДАЧА БОЛЬШИХ ДАННЫХ
// тут выгодно передавать указатели на данные
// а не сами данные
// но тут могут быть проблемы
// нужно чтобы данные были до конца записаны одним источником
// и доконца прочитаны другим
// короче тут все проблемы с паралельностью

//>> ОЧЕРЕДИ ВНУТРИ ПРЕРЫВАНИЯ
// для прерываний есть защищенные функции
//<< вставка данных вначало очереди
xQueueSendToFrontFromISR(очередь, *что_кладем, *разбудить_более_приоритетную_задачу)
// вернет
pdPASS - если успех
errQUEUE_FULL - если ошибка

// разбудить_более_приоритетную_задачу - это параметр в который попадет значение
// которое говорит имеет ли задача которая ждет симафор выше приоритет чем прерванная по прерыванию
// если да то возможно нужно сделать 
portSWITCH_CONTEXT();

//<< вставка данных в конец
xQueueSendToBackFromISR(очередь, *что_кладем, *разбудить_более_приоритетную_задачу)
// вернет
pdPASS - если успех
errQUEUE_FULL - если ошибка

// разбудить_более_приоритетную_задачу - это параметр в который попадет значение
// которое говорит имеет ли задача которая ждет симафор выше приоритет чем прерванная по прерыванию
// если да то возможно нужно сделать 
portSWITCH_CONTEXT();

//<< получение данных
xQueueReceiveFromISR(очередь, *переменная_куда_писать)
// вернет
pdPASS - если успех
errQUEUE_FULL - если ошибка

//>> КАК ИСПОЛЬЗОВАТЬ ЭФФЕКТИВНО
// не используй для передачи больших данных
