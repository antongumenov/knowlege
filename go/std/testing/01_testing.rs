package main

import (
	"sort"
	"testing"
)

//_ ОРГАНИЗАЦИЯ МОДУЛЬНОГО ТЕСТИРОВАНИЯ
// тесты лежат в папке пакета
// имеют тот же пакет, соответственно имеют доступ ко всем функциям пакета
// имена файлов тестов заканчиваются на _test.go, типа , simple_test.go
// тест - это функция с именем начинающимся на Test и далее какое то имя, типа TestSum
// и принимают структуру типа testing.T
// в которой и реализованы все методы тестирования

//~ тестирование только экспортируемых функций
// если пакет называется напримерmain
// а в тесте указать пакет main_test,
// но так же положить его в эту же папку
// то тест так же будет привязан к пакету main,
// но доступны будут только экспортируемые функции

// _ ПРИМЕР ТЕСТА
func TestSum(t *testing.T) {
	// тестируемые данные
	testValues := []int{10, 20, 30}
	// запускаю функцию обьявленную в пакете main
	_, sum := sortAndTotal(testValues)
	// что ожидаю на выходе
	expected := 60
	// сравниваю результат
	if sum != expected {
		t.Fatalf("Expected %v, Got %v", expected, sum)
	}
}

// --- FAIL: TestSum (0.00s)
//     simple_test.go:33: Expected 60, Got 63
// FAIL

//~ тестов может быть несколько в одном файле

func TestSort(t *testing.T) {
	testValues := []int{1, 279, 48, 12, 3}
	sorted, _ := sortAndTotal(testValues)
	if !sort.IntsAreSorted(sorted) {
		t.Fatalf("Unsorted data %v", sorted)
	}
}

//_ МЕТОДЫ СТРУТУРЫ testing.T
//~ Log(...vals)
// записывает vals в журнал оштбок
//~ Logf(template, ...vals)
// записывает vals по шадлону в журнал ошибок
//~ Fail()
// помечает тест как не пройденый и продолжает тест
//~ FailNow()
// помечает тест как провеленный и прекращает тест
//~ Failed()
// возвращает true, если тест провален,
// используется для прверки внутри теста
//~ Error(...errs)
// связка Log() c Fail()
// то есть печатает errs в журнал ошибок,
// помечает тест как не пройденный но продолжает его
//~ Errorf(template, ...errs)
// связка Logf() c Fail()
// то есть печатает errs в журнал ошибок по шаблону,
// помечает тест как не пройденный но продолжает его
//~ Fatal(...vals)
// связка Log() c FailNow()
// то есть печатает errs в журнал ошибок,
// помечает тест как не пройденный и прекращает его
//~ Fatalf(template, ...vals)
// связка Logf() c FailNow()
// то есть печатает errs в журнал ошибок по шаблону,
// помечает тест как не пройденный и прекращает его

//_ МЕТОДЫ УПРАВЛЕНИЯ ТЕСТАМИ СТРУКТУРЫ testing.T
//~ Run(name, func)
// вызов теса внутри другого теста
// возвращает bool, пройден тест ии нет
//~ SkipNow()
// прекращение теста с отметкой как пропущенный
// используется когда нет смысла продолжать тестирование
//~ Skip(...args)
// связка Log() c SkipNow()
// то есть вывод args в журнал ошибок и пометка теста как пропущеного
//~ Skipа(template, ...args)
// связка Logf() c SkipNow()
// то есть вывод args в журнал ошибок по шаблону и пометка теста как пропущеного
//~ Skiped()
// возвращает пропущен ли тест, используется в ходе теста для проверки состояния

//_ ЗАПУС МОДУЛЬНЫХ ТЕСТОВ
//~ go test
// запуск всех тестов без подробностей

// если все тктсы успешны просто выдаст что все пройдено,
// без информации по конкретным тестам
// но если что то провалилось выдаст инфу по проваленному тесту
// и сообщение журнала ошибок

// --- FAIL: TestSum (0.00s)
//     simple_test.go:33: Expected 60, Got 63
// FAIL
// exit status 1
// FAIL    playground      0.006s

//~ go test -v
// запуск тестов с подробностями
// выведет статус по всем тестам, по пройденным и не пройденным

//~ go test -run "test_mane"
// запуск конкретного теста

//~ go test -v -run "test_mane"
// запуск конкретного теста с подробной инфой

//_ УСКОРЕНИЕ ТЕСТИРОВАНИЯ
// можно создать простой шаблон для тестирования на дженериках
// и сделать как сниппет
// так как любой тест - это прием проверяемого значения
// прием имени функции
// и сравнение
