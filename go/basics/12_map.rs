//>> MAP
// структура хранящая значения по уникальным ключам

//<< обьявление с начальным размером
// у мап нет емкости
products := make(map[string]float64, 10)

//<< добавление значений
products["Kayak"] = 279

//<< литеральный синтаксис обьявления
products := map[string]float64 {
    "Kayak" : 279,
    "Lifejacket": 48.95,
}

//<< получение значений
// из мапы в val упадет либо значение по ключу, если оно есть в мапе
// либо, если по такому ключу значения нет, вернется значение типа по умолчанию
// проверить что там можно проверив ок
// если ок=true, то я получил значение по ключу
// иначе я получил дефолтное значение, и значения по ключу нет
val, ok := products["Kayak"]

//<< удаление
delete(products, "Kayak")

//<< длинна
fmt.Println("Price:", products["Kayak"])

//>> ИТЕРАЦИЯ ПО МАПЕ
for key, value := range products {
    fmt.Println("Key:", key, "Value:", value)
}

//>> БАКЕТЫ, ПАМЯТЬ, ЭВАКУАЦИЯ
// мапа состоит из бакетов
// по которым равномерно распределяются элементы
// при заполнении бакуетов в среднем на 6,5 значений из 8 в бакете
// происходит пересоздание мапы с в 2 раза большим количеством бакетов
// и значения из старой мапы переносятся туда
// но не сразу а при добавлении и удалении
// по этому какое то время существует и старая и новая мапа одновременно
// этот процесс называется эвакуацией
// чтобы этого избежать, нужно планировать размер мапы
// и сразу выделять под нее память при создании
// тогда все будет работать быстрее
products := make(map[string]float64, 1000)

//>> НЮАНСЫ
// указатель на элемент мапы взять нельзя, так как это безсмысленно в случае эвакуации
// перебор мапы всегда в случайном порядке