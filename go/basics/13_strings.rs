//>> ДВОЙНАЯ ПРИРОДА СТРОК
// го обрабатывает строки как массивы байтов
// по этому я могу иметь доступ по индексу и диапазоны
// из строки с сиволами ASCII я могу вытащить отдельный символ
// и часть строки

var price string = "$48.95"
// эта запись возвратит тип byte
var currency byte = price[0]// 36
// чтобы получить символ нужно явно приобразовать в строку
var currency string = string(price[0])// $
// срез же можно сразу присвоить строке
var amountString string = price[1:]// 48,95

// но с символами unicode так не прокатит
// если я ввиду символ валюты евро
var price string = "€48.95"
// то здесь будет непонятный символ
var currency string = string(price[0])
// а здесь ошибка
var amountString string = price[1:]
// потому что символ евро занимает три байта

//>> РАЗБОР СТРОК ПО СИМВОЛАМ
// нужно конвертнуть строку в срез рун и потом перебирать, 
// доставать символы и части текста
var price []rune = []rune("€48.95")
var currency string = string(price[0])// €
var amountString string = string(price[1:])// 48.95

//>> ПОЧЕМУ ТАК
// байты важны когда ты хочешь знать сколько тебе нужно места для хранения
// символы нужны для работы с содержимым строк

//>> ДЛИННА СТРОКИ В РУНАХ
utf8.RuneCountInString(message)

//>> ПЕРЕБОР СТРОК 
var message string = "Привет, мир!"
//<< побуквенный вывод строки в случае range
for _, char := range message {
	fmt.Println(string(char)) 
}
//<< побайтовый вывод строки в случае цикла for
for i := 0; i < len(message); i++ {
	// в данном случае символы будут содержать некорректные значения
	fmt.Println(string(message[i])) 
}

