// _ ИСПОЛЬЗОВАНИЕ БЛОКИРОВОК ПО УСЛОВИЮ
// когда есть несколько горутин
// которые не только используют общие данные
// но одна горутина готовит данные и должна полюбому быть отдельной горутиной
// а остальные читают и работают уже с готовыми данными
// и соответственно ведущая горутина должна их подготовить
// а остальные подождать пока основная не даст сигнал
// используется блокировка по условию

// _ КАК ЭТО РЕАЛИЗОВАТЬ
// создаю группу ожидания
var waitGroup = sync.WaitGroup{}

// создаю мьютекс
var rwmutex = sync.RWMutex{}

//~ NewCond(*RWMutex)
// возвращаю структуру Cond с помощью функции RLocker(),
// в которую передаю Locker из RWMutex

// стрктура Cond содержит в себе
// L - экземпляр Locker, который может получить блокировку на чтение
// методом Lock() и отпустить методом Unlock()

// а так же реализацию методов
// Wait() - говорит горутине заблокироваться, отпустить данные,
// пока не будет сигнала проснуться, используется в зависимых горутинах

// Signal() - говорит одной горутине которая первая в ожидании
// разблокироваться и использовать данные

// Broadcast() - говорит всем ожидающим горутинам разблокироваться
// и использовать данные
var condLocker = sync.NewCond(rwmutex.RLocker())

// создаю общие данные
var squares = map[int]int{}

// в основной горутине
func generateSquares(max int) {
	// блокирую мьютекс на запись делаю операции с данными
	rwmutex.Lock()
	fmt.Println("Generating data...")
	for val := 0; val < max; val++ {
		squares[val] = int(math.Pow(float64(val), 2))
	}
	// разблокирую
	rwmutex.Unlock()
	fmt.Println("Broadcasting condition")

	//~ Broadcast()
	// даю всем кто ждет чтобы разблокировались и читали данные
	condLocker.Broadcast()
	// говорю что горутина отработала
	waitGroup.Done()
}

// в зависимой горутине
func readSquares(id, max, iterations int) {

	//~ Lock()
	// пробую получить блокировку на чтение
	// и если не получил, жду
	// если получил
	// то блокирую данные
	condLocker.L.Lock()

	//~ Wait()
	// проверяю общие данные
	// если они не удовлетворяют условиям
	// говорю ждем пока не будет дан сигнал
	// тут горутина разблокирует данные и сама блокируется
	for len(squares) == 0 {
		condLocker.Wait()
	}
	// если с данными все норм
	// или получил сигнал, читаю данные
	// здесь горутина получает блокировку над данными, если она первая
	// или ждет пока ее не отпустят предидущие
	for i := 0; i < iterations; i++ {
		key := rand.Intn(max)
		fmt.Printf("#%v Read value: %v = %v\n", id, key,
			squares[key])
		time.Sleep(time.Millisecond * 100)
	}

	//~ Unlock()
	// когда все сделал
	// разблокирую мьютекс и говорю что эта горутина отработала
	condLocker.L.Unlock()
	waitGroup.Done()
}
func main() {
	numRoutines := 2
	waitGroup.Add(numRoutines)
	// две зависимые горутины встанут пока не будет заполнены данные
	for i := 0; i < numRoutines; i++ {
		go readSquares(i, 10, 5)
	}
	waitGroup.Add(1)
	// заполню данные и пробуждаю горутины
	go generateSquares(10)
	// жду оставшиеся горутины
	waitGroup.Wait()
	fmt.Printf("Cached values: %v\n", len(squares))
}
