//>> КАНАЛЫ
// это контейнер в который можно положить значение в одной горутине
// и получить из другой
// по каналу можно передавать только данные определенного типа

//>> РАБОТА С НЕБУФЕРЕЗИРОВАННЫМИ КАНАЛАМИ 
// не буферизированный канал может хранить только одно значение

// вне горутины создаю канал(тут в канал можно кидать тип int)
// обязательно инициализирую
var intCh chan int = make(chan int)

// канал нужно передать в горутину
go func(intCh chan int){
    // тут кладем в него данные
    // здесь важно понимать, при пеердачи данных в канал
    // горутина заблокируется, пока данные не будут получены из канала
    intCh<-5
}(intCh)

// получаем данные
// здесь важно понять, что горутина заблокируется пока данные не поступят в канал
// или канал не закроется
result := <- intCh

//>> РАБОТА С БУФЕРИЗИРОВАННЫМИ КАНАЛАМИ
// это каналы которые могут хранить несколько значений
// и в них сразу можно положить все значения
// и горутина отправитель заблокируется только тогда когда буфер заполнится

// горутина получатель будет получать значения до тех пор, 
// пока в буфере не закончатся значения 

// в основной горутине инициализируем буферизированный канал на 2 элемента
var intCh chan int = make(chan int, 2)

// передаем его в горутину
go func(intCh chan int){
    intCh<-5
    intCh<-6
}(intCh)

// получаем значения
result := <- intCh
fmt.Println(result)
result2 := <- intCh
fmt.Println(result2)

//>> ЗАКРЫТИЕ КАНАЛА, ПОЛУЧЕНИЕ ЗНАЧЕНИЙ С ПРОВЕРКОЙ НА ЗАКРЫТИЕ
// го не требует закрытия каналов
// как правило я знаю сколько горутин я запустил
// по этому получать значения можно через цикл, указав число титераций
// и мне не нужно думать о закрытии канала

// но бывают ситуации когда не возможно узнать сколько значений передано в канал
// в таких ситуациях после отправки последнего значения, нужно закрытиь канал
// а при получении получать значения из канала в бесконечном цикле
// делая выход из цикла когда канал закрыт

intCh := make(chan int, 2)
go func(intCh chan int){
    intCh<-5
    intCh<-6
    close(chanal)
}(intCh)

// получаю так
// из канала всегда вторым значением прилетает флаг закрытия канала
for {
    if val, open := <- intCh; open {
        fmt.Println(val)
    } else {
        fmt.Println("Channel has been closed")
        break
    }
}

//<< использование цикла for range
// в таком случае проверку делать не нужно
// цикл закончится сам
// но закрывать канал нужно по любому
// иначе цикл не закончится и будет ждать данные
for val := range dispatchChannel {
    fmt.Println(val)
}

//>> ОГРАНИЧЕНИЕ НАПРАВЛЕНИЯ КАНАЛА
// используется для уменьшения ошибок
// когда передаем каналы в функции можем ограничить их направление

// здесь разрешаю каналу только отправлять данные
go func(intCh chan<- int){
    val:=<-intCh// ошибка, получение данных из канала не возможно
}(intCh)

// здесь разрешаю каналу только получать данные
go func(intCh <-chan int){
    intChan <- 1// ошибка, отправка в канал не возможна
}(intCh)

//>> СИНХРОНИЗАЦИЯ C ПОМОЩЬЮ КАНАЛОВ
// с помощью каналов можно реализовать поведение типа await
func main() {
	intChan := make(chan int)
	go func(intChan chan int) {
		defer close(intChan)
		fmt.Println("Gorutine")
	}(intChan)

    // тут мы типа говорим, подожди пока канал не закроется
	<-intChan //! из закрытого канала летят данные по умолчанию

	fmt.Println("Main")
}